// Generated by CoffeeScript 1.8.0
(function() {

  var Decoder, debug, encodeHelper, logger, util;

  util = require('util');

  debug = require('debug');

  var commonModule = require('./common');
  encodeHelper = commonModule.encodeHelper;
  var keywordStrings = commonModule.keywordStrings;
  var ServerIdentifier = commonModule.ServerIdentifier;

  logger = debug('nodermi:decode');

  Decoder = (function() {
    function Decoder(server, source, sessionId) {
      if (sessionId == null) {
        throw new Error("sessionId is mandatory");
      };
      var _ref;
      this.server = server;
      this.source = source;
      _ref = this.server, this.host = _ref.host, this.port = _ref.port, this.objectRegistry = _ref.objectRegistry;
      this.decoded = {};
      this.sessionId = sessionId;
    }

    Decoder.prototype.decode = function(obj) {
      return this._decode(obj);
    };

    Decoder.prototype._decode = function(obj) {
      var i, id, remoteType, result, _i, _len;
      if ((obj == null) || (typeof obj !== 'object' && typeof obj !== 'function')) {
        return obj;
      }
      if (util.isArray(obj)) {
        result = [];
        for (_i = 0, _len = obj.length; _i < _len; _i++) {
          i = obj[_i];
          result.push(this._decode(i));
        }
        return result;
      }
      id = encodeHelper.getRid(obj);
      // it is from here
      if (encodeHelper.isOriginEquals(obj, 1)) {
        result = this.objectRegistry.getObject(id);
        if (result == null) {
          logger("cannot find object " + id);
        }
        this._markDecoded(obj, result);
        return result;
      }
      remoteType = encodeHelper.getFullRemoteType(obj);
      switch (remoteType) {
        case keywordStrings.funcDes():
          return this._decodeFunction(obj);
        case keywordStrings.arrDes():
          return this._decodeArray(obj);
        case keywordStrings.dateDes():
          return this._decodeDate(obj);
        case keywordStrings.buffer() :
          return this._decodeBuffer(obj);
        case keywordStrings.pojo():
          return this._decodePojo(obj);
        case keywordStrings.ref():
          return this._decodeRef(obj);
        default:
          return this._decodeObj(obj);
      }
    };
    // remember what has been decoded so far, to resolve cyclic reference.
    // objDesc is remote object descriptor, result is the object stub created
    Decoder.prototype._markDecoded = function(objDesc, result) {
      var remoteHost, remotePort;
      if (encodeHelper.isOriginEquals(objDesc, 1)) {
        // it is from myself
        this._markDecoded2(this.host, this.port, encodeHelper.getRid(objDesc), result);
        return;
      }
      remoteHost = encodeHelper.getHiddenRhost(result);
      remotePort = encodeHelper.getHiddenRport(result);
      return this._markDecoded2(remoteHost, remotePort, encodeHelper.getRid(objDesc), result);
    };

    Decoder.prototype._markDecoded2 = function(host, port, id, result) {
      if (this.decoded[host] == null) {
        this.decoded[host] = {};
      }
      if (this.decoded[host][port] == null) {
        this.decoded[host][port] = {};
      }
      return this.decoded[host][port][id] = result;
    };

    Decoder.prototype._decodeFunction = function(obj) {
      var func, funcId, server, source;
      source = this._getSource(obj);
      server = this.server;
      funcId = encodeHelper.getRid(obj);
      func = (function(source, funcId, server) {
        return function() {
          var thisObj = null;
          // pass this if it is from source
          if (this!=null && encodeHelper.getHiddenRhost(this) == source.host 
            && encodeHelper.getHiddenRport(this) == source.port) {
            thisObj = encodeHelper.getHiddenRid(this);
          }
          return server._invokeRemoteFunc(source, funcId, thisObj, arguments);
        };
      })(source, funcId, server);
      this._setRmiFields(func, obj);
      this._markDecoded(obj, func);
      this.objectRegistry.registerStub(func);
      return func;
    };

    Decoder.prototype._getSource = function(obj) {
      var remoteHost, remotePort, source;
      remoteHost = encodeHelper.getRhost(obj);
      remotePort = encodeHelper.getRport(obj);
      source = null;
      if ((remoteHost == null) && (remotePort == null)) {
        source = this.source;
      } else {
        source = new ServerIdentifier(remoteHost, remotePort);
      }
      return source;
    };

    Decoder.prototype._decodeArray = function(obj) {
      var arrayElements, i, result, _i, _len;
      result = [];
      this._setRmiFields(result, obj);
      this._markDecoded(obj, result);
      arrayElements = encodeHelper.getArrayElements(obj);
      if (arrayElements != null) {
        for (_i = 0, _len = arrayElements.length; _i < _len; _i++) {
          i = arrayElements[_i];
          result.push(this._decode(i));
        }
      }
      return result;
    };

    // fill rmi id, host, etc to the stub object
    Decoder.prototype._setRmiFields = function(stubObj, objDesc) {
      var objId = encodeHelper.getRid(objDesc);
      encodeHelper.setHiddenRid(stubObj, objId);
      var remoteHost = encodeHelper.getRhost(objDesc);
      var remotePort = encodeHelper.getRport(objDesc);
      var sessionId = null;
      // the object is from source
      if (remoteHost == null) {
        remoteHost = this.source.host;
        remotePort = this.source.port;
        sessionId = this.sessionId;
      }else{
        sessionId = encodeHelper.getSessionId(objDesc);
        if (sessionId == null) {
          var errorMsg = "Obect " + remoteHost + ":" + remotePort
            + " " + objId + " do not have sessionId.";
          errorLogger(errorMsg);
          throw new Error(errorMsg);
        }
      }
      encodeHelper.setHiddenRhost(stubObj, remoteHost);
      encodeHelper.setHiddenRport(stubObj, remotePort);
      encodeHelper.setHiddenSessionId(stubObj, sessionId);
    };

    Decoder.prototype._decodeDate = function(obj) {
      var time = encodeHelper.getObjectValue(obj);
      var result = new Date(time);
      return result;
    };

    Decoder.prototype._decodeBuffer = function(obj) {
      var bufferStr = encodeHelper.getObjectValue(obj);
      var result = new Buffer(bufferStr, 'base64');
      return result;
    };

    Decoder.prototype._decodePojo = function(obj) {
      return encodeHelper.getProperties(obj);
    };

    Decoder.prototype._decodeObj = function(obj) {
      var func, funcName, functions, k, objId, properties, result, server, source, v, _i, _len;
      result = {};
      this._setRmiFields(result, obj);
      this._markDecoded(obj, result);
      properties = encodeHelper.getProperties(obj);
      if (properties != null) {
        for (k in properties) {
          v = properties[k];
          result[k] = this._decode(v, obj);
        }
      }
      // every stub created should be registered exactly once !
      this.objectRegistry.registerStub(result);
      return result;
    };

    Decoder.prototype._decodeRef = function(objDesc) {
      var id, remoteHost, remotePort, _ref, _ref1;
      id = encodeHelper.getRid(objDesc);
      remoteHost = encodeHelper.getRhost(objDesc);
      remotePort = encodeHelper.getRport(objDesc);
      if ((remoteHost == null) && (remotePort == null)) {
        remoteHost = this.source.host;
        remotePort = this.source.port;
      }
      return (_ref = this.decoded[remoteHost]) != null ? (_ref1 = _ref[remotePort]) != null ? _ref1[id] : void 0 : void 0;
    };

    return Decoder;

  })();

  module.exports = Decoder;

}).call(this);
