// Generated by CoffeeScript 1.8.0
(function() {
  var Decoder, Encoder, ObjectRegistry, Server, debug, emptyObj, encodeHelper, excludeMethods, logger, privatePrefix, util, _ref;

  util = require('util');

  debug = require('debug');

  ObjectRegistry = require('./object_registry');

  _ref = require('./common'), encodeHelper = _ref.encodeHelper, privatePrefix = _ref.privatePrefix, excludeMethods = _ref.excludeMethods;

  Encoder = require('./encoding');

  Decoder = require('./decoding');

  logger = debug('nodermi:server');

  emptyObj = {};

  Server = (function() {
    function Server(options, callback) {
      var FileLogger, HttpTransport;
      this.host = options.host, this.port = options.port;
      this.objectRegistry = new ObjectRegistry();
      this.privatePrefix = privatePrefix;
      this.excludeMethods = excludeMethods;
      this.serverObj = {};
      FileLogger = require('./file_logger');
      this.fileLogger = new FileLogger(options);
      HttpTransport = require('./http_transport');
      this.transport = new HttpTransport(this);
      this.transport.on('message', this.requestHandler.bind(this));
      this.transport.once('initialized', (function(_this) {
        return function(err) {
          return callback(err, _this);
        };
      })(this));
    }

    Server.prototype.requestHandler = function(message, response) {
      var args, destination, funcName, objId, objName;
      destination = {
        host: encodeHelper.getRhost(message),
        port: encodeHelper.getRport(message)
      };
      logger("got request " + (JSON.stringify(message)));
      switch (encodeHelper.getFullMessageType(message)) {
        case 'retrive':
          objName = encodeHelper.getObjectName(message);
          return this._handleRetriveObj(objName, destination, response);
        case 'invoke':
          objId = encodeHelper.getObjectId(message);
          funcName = encodeHelper.getFunctionName(message);
          args = encodeHelper.getArgs(message);
          return this._handleInvokeFunction(objId, funcName, args, destination, response);
      }
    };

    Server.prototype._handleRetriveObj = function(objName, destination, response) {
      var encoded, encoder, obj;
      obj = objName != null ? this.serverObj[objName] : this.serverObj;
      encoder = new Encoder(this, destination);
      encoded = encoder.encode(obj);
      return response.write(encoded);
    };

    Server.prototype._handleInvokeFunction = function(objId, funcName, args, source, response) {
      var decodedArgs, decoder, obj;
      obj = this.objectRegistry.getObject(objId);
      if (obj == null) {
        logger("cannot find obj " + objId);
        response.write(this._erroMessage("cannot find obj " + objId));
        return;
      }
      decodedArgs = [];
      if ((args != null) && args.length > 0) {
        decoder = new Decoder(this, source);
        decodedArgs = decoder.decode(args);
      }
      if (funcName != null) {
        obj[funcName].apply(obj, decodedArgs);
      } else {
        obj.apply(emptyObj, decodedArgs);
      }
      return response.write(this._successMessage());
    };

    Server.prototype._createMessage = function(type) {
      var message;
      message = {};
      encodeHelper.setMessageType(message, type, true);
      encodeHelper.setRhost(message, this.host);
      encodeHelper.setRport(message, this.port);
      return message;
    };

    Server.prototype._successMessage = function() {
      var message;
      message = this._createMessage('success');
      return message;
    };

    Server.prototype._erroMessage = function(msg) {
      var message;
      message = this._createMessage('error');
      encodeHelper.setProperties(message, msg);
      return message;
    };

    Server.prototype._invokeRemoteMethod = function(destination, objId, funcName, args) {
      var encodedArgs, message;
      message = this._createMessage('invoke');
      encodeHelper.setObjectId(message, objId);
      encodeHelper.setFunctionName(message, funcName);
      encodedArgs = this._encodeArguments(destination, args);
      encodeHelper.setArgs(message, encodedArgs);
      return this.transport.send(destination, message, (function(_this) {
        return function(err, returnMessage) {
          return _this._invokeResponseHandler(args, err, returnMessage);
        };
      })(this));
    };

    Server.prototype._encodeArguments = function(destination, args) {
      var encoder, i, result, _i, _len;
      result = null;
      if ((args != null) && args.length > 0) {
        encoder = new Encoder(this, destination);
        result = [];
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          i = args[_i];
          result.push(encoder.encode(i));
        }
      }
      return result;
    };

    Server.prototype._invokeRemoteFunc = function(destination, funcId, args) {
      var encodedArgs, message;
      message = this._createMessage('invoke');
      encodeHelper.setObjectId(message, funcId);
      encodedArgs = this._encodeArguments(destination, args);
      encodeHelper.setArgs(message, encodedArgs);
      return this.transport.send(destination, message, (function(_this) {
        return function(err, returnMessage) {
          return _this._invokeResponseHandler(args, err, returnMessage);
        };
      })(this));
    };

    Server.prototype._invokeResponseHandler = function(args, err, returnMessage) {
      var callback, error;
      error = err;
      if ((error == null) && encodeHelper.getFullMessageType(returnMessage) === 'error') {
        error = encodeHelper.getProperties(returnMessage);
      }
      if (error != null) {
        if ((args != null ? args.length : void 0) > 0 && typeof args[args.length - 1] === 'function') {
          callback = args[args.length - 1];
          return callback(error);
        } else {
          return logger("invoke remote method error " + error);
        }
      }
    };

    Server.prototype.retriveObj = function(options, callback) {
      var destination, message;
      destination = {
        host: options.host,
        port: options.port
      };
      message = this._createMessage('retrive');
      encodeHelper.setObjectName(message, options.objName);
      return this.transport.send(destination, message, (function(_this) {
        return function(err, returnMessage) {
          var decoder;
          if (err != null) {
            return callback(err);
          }
          decoder = new Decoder(_this, destination);
          return callback(null, decoder.decode(returnMessage));
        };
      })(this));
    };

    Server.prototype.createSkeleton = function(endPoint, obj) {
      return this.serverObj[endPoint] = obj;
    };

    return Server;

  })();

  module.exports = Server;

}).call(this);
