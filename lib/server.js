// Generated by CoffeeScript 1.8.0
(function() {
  var Decoder, Encoder, ObjectRegistry, Server, debug, emptyObj, encodeHelper, excludeMethods, logger, privatePrefix, util, _ref;

  util = require('util');

  debug = require('debug');
  var lodash = require('lodash');
  var async   = require('async');

  ObjectRegistry = require('./object_registry');

  _ref = require('./common'), encodeHelper = _ref.encodeHelper, privatePrefix = _ref.privatePrefix,
  excludeMethods = _ref.excludeMethods;

  var ServerIdentifier = _ref.ServerIdentifier;
  var keywordStrings = _ref.keywordStrings;

  Encoder = require('./encoding');

  Decoder = require('./decoding');
  var FailureDetector = require("./failure_detector");

  logger = debug('nodermi:server');
  errorLogger = debug('nodermi:error:server');

  emptyObj = {};

  Server = (function() {
    function Server(options, callback) {
      var FileLogger, HttpTransport;
      this.host = options.host;
      this.port = options.port;
      this._host = new ServerIdentifier(options.host, options.port);
      this.objectRegistry = new ObjectRegistry();
      this.privatePrefix = privatePrefix;
      this.excludeMethods = excludeMethods;
      this.serverObj = {};
      this.sequence = 0;
      FileLogger = require('./file_logger');
      this.fileLogger = new FileLogger(options);
      HttpTransport = require('./http_transport');
      this.transport = new HttpTransport(this);
      this.transport.on('message', this._requestHandler.bind(this));
      this.transport.once('initialized', (function(_this) {
        return function(err) {
          return callback(err, _this);
        };
      })(this));
      this.objectRegistry.on('dereference', this._sendDereference.bind(this));

      var failureDetector = new FailureDetector({
        server : this
      });
      this.failureDetector = failureDetector;
      this.transport.on('sendSuccess', function(destination){
        failureDetector.update(destination);
      });
    }

    Server.prototype._generateSessionId = function(){
      var id = this.sequence.toString(36);
      this.sequence++;
      return id;
    };

    Server.prototype._requestHandler = function(message, response) {
      var destination = new ServerIdentifier(encodeHelper.getRhost(message),
        encodeHelper.getRport(message));
      // receive a request from destination, it must be alive
      this.failureDetector.update(destination);
      if (logger.enabled) {
        logger(this._host + " got request " + (JSON.stringify(message)));
      }
      var messageType = encodeHelper.getFullMessageType(message);
      switch (messageType) {
        // get object
        case keywordStrings.retrieve():
          var objName = encodeHelper.getObjectName(message);
          return this._handleretrieveObj(objName, destination, response);
        // handle method call
        case keywordStrings.invoke():
          var functionId = encodeHelper.getFunctionId(message);
          var thisId = encodeHelper.getObjectId(message);
          var args = encodeHelper.getArgs(message);
          var sessionId = encodeHelper.getSessionId(message);
          return this._handleInvokeFunction(sessionId, functionId, thisId, args, destination, response);
        case keywordStrings.reference():
          // the reference message are not directly sent by the actual client
          var client = encodeHelper.getReferenceClient(message);
          client = new ServerIdentifier(client[0], client[1]);
          var referenceMap = encodeHelper.getObjectValue(message);
          return this._handleReference(client, referenceMap, response);
        case keywordStrings.dereference():
          // dereference messages are sent by the actual client
          var client = new ServerIdentifier(encodeHelper.getRhost(message), 
            encodeHelper.getRport(message));
          var sessionId = encodeHelper.getSessionId(message);
          var objId = encodeHelper.getObjectId(message);
          return this._handleDereference(client, sessionId, objId, response);
        case keywordStrings.ping():
          return this._handlePing(response);
        default:
          errorLogger("unknown message type " + messageType);
      }
    };

    Server.prototype._handleReference = function(client, referenceMap, response){
      for (var sessionId in referenceMap) {
        var objIds = referenceMap[sessionId];
        for (var i = 0; i < objIds.length; i++) {
          var objId = objIds[i];
          var obj = this.objectRegistry.getObject(objId);
          if (obj == null) {
            var errorMsg = "Reference failed, cannot find " + objId;
            errorLogger(errorMsg);
            response.write(this._erroMessage(errorMsg));
            return;
          }else{
            this.objectRegistry.registerObject(obj, sessionId, client);
          }
        }
      }
      response.write(this._successMessage());
    };

    Server.prototype._handleDereference = function(client, sessionId, objId, response){
      this.objectRegistry.dereference(client, sessionId, objId);
      response.write(this._successMessage());
    };
    Server.prototype._handlePing = function(response){
      response.write(this._successMessage());
    };

    Server.prototype._sendDereference = function(host, sessionId, objId){
      var message = this._createMessage(keywordStrings.dereference());
      encodeHelper.setSessionId(message, sessionId);
      encodeHelper.setObjectId(message, objId);
      this.transport.send(host, message);
    };

    Server.prototype._sendPing = function(host, callback){
      var message = this._createMessage(keywordStrings.ping());
      this.transport.send(host, message, callback);
    };

    // remove reference from failed servers
    Server.prototype._removeReferenceFrom = function(serverList){
      this.objectRegistry.removeReferenceFrom(serverList);
    };

    Server.prototype._handleretrieveObj = function(objName, destination, response) {
      var obj = objName != null ? this.serverObj[objName] : this.serverObj;
      var sessionId = this._generateSessionId();
      var encoder = new Encoder(this, destination, sessionId);
      var encoded = encoder.encode(obj);
      var responseMsg = {};
      encodeHelper.setSessionId(responseMsg, sessionId);
      encodeHelper.setObjectValue(responseMsg, encoded);
      // the client needs to reference stub from other server
      if (encoder.hasStubReference()) {
        self = this;
        this._sendReferenceMessages(destination, encoder.stubReferences, function(err){
          if (err != null) {
            errorLogger(err);
            response.write(self._erroMessage(err));
            return;
          }
          response.write(responseMsg)
        });
      }else{
        response.write(responseMsg);
      }
    };
    // send reference for client, client is the one that needs to hold new stubs
    Server.prototype._sendReferenceMessages = function(client, referencesMap, callback){
      var allReferences = lodash.values(referencesMap);
      var self = this;
      async.each(allReferences, function(references, next){
        // host is where the referece lives
        var host = references[0].host;
        var message = self._createMessage(keywordStrings.reference());
        // organize the references as sessionId->array of objectIds
        var organized = {};
        for (var i = 0; i < references.length; i++) {
          var reference = references[i];
          if (organized[reference.sessionId] == null) {
            organized[reference.sessionId] = [reference.objId];
          }else{
            var found = lodash.indexOf(organized[reference.sessionId], reference.objId);
            if (found < 0) {
              organized[reference.sessionId].push(reference.objId);
            }
          }
        };
        encodeHelper.setReferenceClient(message, [client.host, client.port]);
        encodeHelper.setObjectValue(message, organized);
        self.transport.send(host, message, function(err, returnMessage){
          self._handleResponse(err, returnMessage, next);
        });
      }, callback);
    }

    // handle a error or null response
    Server.prototype._handleResponse = function(err, returnMessage, callback){
      var error = err;
      if ((error == null) && encodeHelper.getFullMessageType(returnMessage) === keywordStrings.error()) {
        error = encodeHelper.getProperties(returnMessage);
      }
      if (callback != null) {
        callback(error);
      }else{
        return error;
      }
    };

    Server.prototype._handleInvokeFunction = function(sessionId, functionId, thisId, args, source, response) {
      var decodedArgs, decoder, e, obj;
      var thisObject = emptyObj;
      if(thisId != null){
        thisObject =  this.objectRegistry.getObject(thisId);
        if (thisObject == null) {
          var errorMsg = "cannot find 'this' object " + thisId + " for function "+functionId;
          errorLogger(errorMsg);
          response.write(this._erroMessage(errorMsg));
          return;
        }
      }
      var functionObj = this.objectRegistry.getObject(functionId);
      if (functionObj == null) {
        var errorMsg = "cannot find function with id "+ functionId;
        errorLogger(errorMsg);
        response.write(this._erroMessage(errorMsg));
        return;
      }
      try {
        decodedArgs = [];
        if ((args != null) && args.length > 0) {
          decoder = new Decoder(this, source, sessionId);
          decodedArgs = decoder.decode(args);
        }
        functionObj.apply(thisObject, decodedArgs);
        return response.write(this._successMessage());
      } catch (e) {
        errorLogger(e);
        response.write(this._erroMessage(e));
      }
    };
    // if it is a request message, we need to embed your identity in the message.
    // if it is a response message, we do not need to
    Server.prototype._createMessage = function(type) {
      var message;
      message = {};
      encodeHelper.setMessageType(message, type, true);
      encodeHelper.setRhost(message, this.host);
      encodeHelper.setRport(message, this.port);
      return message;
    };

    Server.prototype._successMessage = function() {
      var message = this._createMessage(keywordStrings.success());
      return message;
    };

    Server.prototype._erroMessage = function(msg) {
      var message = this._createMessage(keywordStrings.error());
      if (util.isError(msg)) {
        msg = msg.message;
      }
      encodeHelper.setProperties(message, msg);
      return message;
    };

    Server.prototype._encodeArguments = function(destination, sessionId, args) {
      var encoder, i, result, _i, _len;
      result = null;
      if ((args != null) && args.length > 0) {
        encoder = new Encoder(this, destination, sessionId);
        result = [];
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          i = args[_i];
          result.push(encoder.encode(i));
        }
      }
      return result;
    };

    Server.prototype._invokeRemoteFunc = function(destination, funcId, thisId, args) {
      var message = this._createMessage(keywordStrings.invoke());

      encodeHelper.setFunctionId(message, funcId);
      encodeHelper.setObjectId(message, thisId);
      var sessionId = this._generateSessionId();
      encodeHelper.setSessionId(message, sessionId);

      var encoder = null;
      var encodedArgs = null;
      if ((args != null) && args.length > 0) {
        encoder = new Encoder(this, destination, sessionId);
        encodedArgs = [];
        for (var _i = 0, _len = args.length; _i < _len; _i++) {
          var i = args[_i];
          encodedArgs.push(encoder.encode(i));
        }
      }
      
      encodeHelper.setArgs(message, encodedArgs);
      // FIXME: if there is remote stubs in the args, may need to send reference request
      // first
      var self = this;
      var sendInvoke = function(){
          self.transport.send(destination, message, 
            function(err, returnMessage) {
              return self._invokeResponseHandler(args, err, returnMessage);
            });
      };

      if (encoder != null && encoder.hasStubReference()) {
        this._sendReferenceMessages(destination, encoder.stubReferences, function(err){
          if (err != null) {
            errorLogger(err);
            throw err;
          }
          sendInvoke();
        });
      }else{
        sendInvoke();
      }
    };

    Server.prototype._invokeResponseHandler = function(args, err, returnMessage) {
      var callback, error;
      error = err;
      if ((error == null) && encodeHelper.getFullMessageType(returnMessage) === 'error') {
        error = encodeHelper.getProperties(returnMessage);
      }
      if (error != null) {
        if ((args != null ? args.length : void 0) > 0 && typeof args[args.length - 1] === 'function') {
          callback = args[args.length - 1];
          return callback(error);
        } else {
          errorLogger("invoke remote method error :" + error);
          errorLogger("returnMessage :" + returnMessage);
        }
      }
    };

    Server.prototype.retrieveObj = function(options, callback) {
      var destination = new ServerIdentifier(options.host, options.port);
      var message = this._createMessage(keywordStrings.retrieve());
      encodeHelper.setObjectName(message, options.objName);
      return this.transport.send(destination, message, (function(_this) {
        return function(err, returnMessage) {
          if (err != null) {
            return callback(err);
          }
          if (logger.enabled) {
            logger("retrieveObj response :" + JSON.stringify(returnMessage));
          }
          // the other end's sessionId
          var sessionId = encodeHelper.getSessionId(returnMessage);
          var objectPayload = encodeHelper.getObjectValue(returnMessage);
          var decoder = new Decoder(_this, destination, sessionId);
          return callback(null, decoder.decode(objectPayload));
        };
      })(this));
    };

    Server.prototype.createSkeleton = function(endPoint, obj) {
      return this.serverObj[endPoint] = obj;
    };

    Server.prototype.close = function(){
      this.transport.close();
      this.failureDetector.close();
    };

    return Server;

  })();

  module.exports = Server;

}).call(this);
