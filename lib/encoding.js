// Generated by CoffeeScript 1.8.0
(function() {
  var Encoder, debug, encodeHelper, globalObj, lodash, logger, util, weak;

  util = require('util');

  debug = require('debug');

  weak = require('weak');

  lodash = require('lodash');

  var commonModule = require('./common');
  encodeHelper = commonModule.encodeHelper;
  var keywordStrings = commonModule.keywordStrings;
  var getHostFromStub = commonModule.getHostFromStub;

  logger = debug("nodermi:encoding");
  var errorLogger = debug("nodermi:error:encoding")

  globalObj = global;

  function StubReference(host, sessionId, objId){
    this.host = host;
    this.sessionId = sessionId;
    this.objId = objId;
  }

  Encoder = (function() {
    function Encoder(server, destination, sessionId) {
      if (sessionId == null) {
        throw new Error("sessionId is mandatory.");
      }
      var _ref;
      this.server = server;
      this.destination = destination;
      _ref = this.server, 
      this.host = _ref.host, this.port = _ref.port, this.privatePrefix = _ref.privatePrefix, 
      this.excludeMethods = _ref.excludeMethods, this.objectRegistry = _ref.objectRegistry, 
      this.encodeErrorStack = _ref.encodeErrorStack;
      this.sessionId = sessionId;
      // for cyclic reference detection
      this.encoded = {};

      this.stubReferences = {};
    }

    Encoder.prototype.encode = function(obj) {
      var result = this._encodeObject(obj);
      return result;
    };
    // put encoded object to a map for cyclic reference detection,
    // return true if the object is seen before
    Encoder.prototype._markEncoded = function(obj) {
      var host, id, port;
      host = obj.__r_host != null ? obj.__r_host : this.host;
      if (this.encoded[host] == null) {
        this.encoded[host] = {};
      }
      port = obj.__r_port != null ? obj.__r_port : this.port;
      if (this.encoded[host][port] == null) {
        this.encoded[host][port] = {};
      }
      id = obj.__r_id;
      if (this.encoded[host][port][id]) {
        return true;
      } else {
        this.encoded[host][port][id] = true;
        return false;
      }
    };

    Encoder.prototype._encodeObject = function(obj) {
      var cached, element, funcDesc, k, objDesc, v, _i, _len;
      if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
        return obj;
      }
      if (weak.isWeakRef(obj)) {
        obj = weak.get(obj);
        if (obj == null) {
          return null;
        }
      }
      if (obj === globalObj) {
        var errorMsg = "nodermi Error : trying to serialize global object";
        errorLogger(errorMsg);
        throw new Error(errorMsg);
      }
      if (util.isDate(obj)) {
        return this.__newRemoteDateDesc(obj);
      }
      if (obj instanceof Buffer) {
        return this.__newRemoteBufferDesc(obj);
      }
      if (obj instanceof Error) {
        return this.__newRemoteErrorDesc(obj);
      }
      if (!this._isRemoteStub(obj)) {
        if (this._isPojo(obj)) {
          return this._newPojoDescriptor(obj);
        }
        this.objectRegistry.registerObject(obj, this.sessionId, this.destination);  
      }
      // detect cyclic reference
      cached = this._markEncoded(obj);
      if (cached && typeof obj !== 'function') {
        return this.__createRemoteDesc(obj, 'ref');
      } else {
        if (typeof obj === 'function') {
          funcDesc = this.__newRemoteFunctionDesc(obj);
          return funcDesc;
        }
        objDesc = this.__createRemoteDesc(obj);
        // if this object comes from destination, 
        // do not need to serialize its children
        if (encodeHelper.isOriginEquals(objDesc, 1)) {
          return objDesc;
        }
        if (lodash.isArray(obj)) {
          encodeHelper.setRemoteType(objDesc, 'arrDes', true);
          for (_i = 0, _len = obj.length; _i < _len; _i++) {
            element = obj[_i];
            this.__addArrayElement(objDesc, this._encodeObject(element));
          }
          return objDesc;
        }
        // this mode means only serialize methods
        var methodsOnly = (obj.__r_mode == 'methods');
        for (k in obj) {
          v = obj[k];
          // ignore private keys
          if (this._isPrivate(k, obj.__r_skip, obj.__r_include)) {
            continue;
          }
          if (methodsOnly && typeof v != 'function') {
            continue;
          }
          this.__addPropToRemoteObjDesc(objDesc, k, this._encodeObject(v));
        }
        return objDesc;
      }
    };

    Encoder.prototype._isRemoteStub = function(obj){
      return encodeHelper.getHiddenRhost(obj) != null;
    }

    Encoder.prototype._isPojo = function(obj, depth) {
      var i, k, v, _i, _len;
      // default depth
      if (depth == null) {
        depth = 3;
      }else if (depth <= 0){
        return false;
      }
      if (typeof obj === 'function') {
        return false;
      }
      if (obj != null) {
        if (util.isArray(obj)) {
          for (_i = 0, _len = obj.length; _i < _len; _i++) {
            i = obj[_i];
            if (!this._isPojo(i, depth - 1)) {
              return false;
            }
          }
          return true;
        }
        if (util.isDate(obj) || util.isRegExp(obj) || util.isError(obj)) {
          return false;
        }
        if (typeof obj === 'object') {
          for (k in obj) {
            v = obj[k];
            if (!this._isPojo(v, depth - 1)) {
              return false;
            }
          }
        }
      }
      return true;
    };

    Encoder.prototype._newPojoDescriptor = function(obj) {
      var result = {};
      encodeHelper.setRemoteType(result, keywordStrings.pojo(), true);
      encodeHelper.setProperties(result, obj);
      return result;
    };

    Encoder.prototype.__createRemoteDesc = function(obj, type) {
      var result = {};
      var objId = encodeHelper.getHiddenRid(obj);
      encodeHelper.setRid(result, objId);
      var remoteHost = getHostFromStub(obj);
      if (remoteHost != null) {
        if (remoteHost.equals(this.destination)) {
          // origin = 1 means the object is from destination
          encodeHelper.setOrigin(result, 1);  
        }else{
          var sessionId = encodeHelper.getHiddenSessionId(obj);
          if (sessionId == null) {
            var errorMsg = "object " + remoteHost + " " + objId
              + " do not have sessionId";
            errorLogger(errorMsg);
            throw new Error(errorMsg);
          }
          // the destination references a stub from another host
          var stubReference = new StubReference(remoteHost, sessionId, objId);
          if(this.stubReferences[remoteHost] == null){
            this.stubReferences[remoteHost] = [stubReference];
          }else{
            this.stubReferences[remoteHost].push(stubReference);
          }
          this.stubReferenceExists = true;
          encodeHelper.setRhost(result, remoteHost.host);
          encodeHelper.setRport(result, remoteHost.port);
          encodeHelper.setSessionId(result, sessionId);
        }
      }
      // for local objects, we do not serialize host/port, because the client could 
      // infer these information
      if (type != null) {
        encodeHelper.setRemoteType(result, type, true);
      }
      return result;
    };

    Encoder.prototype.hasStubReference = function(){
      return this.stubReferenceExists;
    };

    Encoder.prototype.__newRemoteFunctionDesc = function(obj) {
      return this.__createRemoteDesc(obj, keywordStrings.funcDes());
    };

    Encoder.prototype.__newRemoteDateDesc = function(obj) {
      var result = {};
      encodeHelper.setRemoteType(result, keywordStrings.dateDes(), true);
      encodeHelper.setObjectValue(result, obj.getTime());
      return result;
    };

    // encode buffer
    Encoder.prototype.__newRemoteBufferDesc = function(obj) {
      var result = {};
      encodeHelper.setRemoteType(result, keywordStrings.buffer(), true);
      encodeHelper.setObjectValue(result, obj.toString('base64'));
      return result;
    };

    Encoder.prototype.__newRemoteErrorDesc = function(obj) {
      var result;
      result = {};
      encodeHelper.setRemoteType(result, keywordStrings.objDes(), true);
      encodeHelper.setProperties(result, {
        message: obj.message,
        name: obj.name
      });
      if (this.encodeErrorStack) {
        encodeHelper.getProperties(result).stack = obj.stack;
      }
      return result;
    };

    Encoder.prototype.__newRemoteArrayDesc = function(obj) {
      return this.__createRemoteDesc(obj, 'arrDes');
    };

    Encoder.prototype.__addPropToRemoteObjDesc = function(desc, key, v) {
      if (encodeHelper.getProperties(desc) == null) {
        encodeHelper.setProperties(desc, {});
      }
      return encodeHelper.getProperties(desc)[key] = v;
    };

    Encoder.prototype.__addArrayElement = function(desc, v) {
      if (encodeHelper.getArrayElements(desc) == null) {
        encodeHelper.setArrayElements(desc, []);
      }
      return encodeHelper.getArrayElements(desc).push(v);
    };

    Encoder.prototype.__addFuncDesc = function(desc, v) {
      if (encodeHelper.getFunctions(desc) == null) {
        encodeHelper.setFunctions(desc, []);
      }
      return encodeHelper.getFunctions(desc).push(v);
    };

    Encoder.prototype._isPrivate = function(name, skipList, includeList) {
      var exclude, include, _i, _j, _k, _len, _len1, _len2, _ref;
      if (includeList != null) {
        if (name === '__r_include') {
          return false;
        }
        if (typeof includeList === 'string' && name === includeList) {
          return false;
        }
        for (_i = 0, _len = includeList.length; _i < _len; _i++) {
          include = includeList[_i];
          if (name === include) {
            return false;
          }
        }
      }
      if ((this.privatePrefix != null) && name.indexOf(this.privatePrefix) === 0) {
        return true;
      }
      if (skipList != null) {
        if (typeof skipList === 'string' && name === skipList) {
          return true;
        }
        for (_j = 0, _len1 = skipList.length; _j < _len1; _j++) {
          exclude = skipList[_j];
          if (name === exclude) {
            return true;
          }
        }
      }
      if (this.excludeMethods != null) {
        _ref = this.excludeMethods;
        for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
          exclude = _ref[_k];
          if (name === exclude) {
            return true;
          }
        }
      }
      return false;
    };

    return Encoder;

  })();

  module.exports = Encoder;

}).call(this);
