// Generated by CoffeeScript 1.8.0
(function() {
  var addHiddenField, createCompressMap, debug, encodeHelper, k, keyWordCode, keyWords, keyWordsMap, keyWordsReverseMap, logger, normalized, v, _i, _len;

  debug = require('debug');

  var lodash = require('lodash');
  var async  = require('async');

  logger = debug('nodermi:common');

  addHiddenField = function(obj, key, val) {
    return Object.defineProperty(obj, key, {
      value: val,
      writable: false,
      enumerable: false,
      configurable: false
    });
  };
/*
  keywords used in constructing rmi messages, remote object stubs and augmenting local
  objects. When used in rmi messages, these keywords are always compressed. 
  When used to constructing stubs or adding new properties in local 
  objects, full name like '__r_id' is used to avoid conflict with the object's own fields.
  This list contains keywords and mappings between readable name to keyword, like 
  ['sessionId', '__r_sid']
*/
  keyWords = ['__r_id', '__r_host', '__r_port', 'origin', 'remoteType', 'arrayElements', 
  'objectValue', 'properties', 'functions', 'serverVersion', 'messageType', 'objectName', 
  'objectId', 'functionName', 'args', 'objDes', 'funcDes', 'arrDes', 'dateDes', 'ref', 
  'retrieve', 'invoke', 'pojo', 'protocolVersion', 'messageId', 'success', 'error',
  'functionId', 'buffer', ['sessionId', '__r_sid'], 'reference', 'dereference', 
  'referenceClient'];

  createCompressMap = function(arr) {
    var compressed, counter, item, map, _i, _len;
    counter = 0;
    map = {};
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      item = arr[_i];
      if (typeof item !== "string") {
        item = item[1];
      }
      if (map[item] == null) {
        compressed = counter.toString(35);
        map[item] = compressed;
        counter++;
      } else {
        throw new Error("duplicate item " + item);
      }
    }
    return map;
  };

  keyWordsMap = createCompressMap(keyWords);

  logger("keyWordsMap " + JSON.stringify(keyWordsMap, null, ' '));


  /*
   keyWordsMap {
 "__r_id": "0",
 "__r_host": "1",
 "__r_port": "2",
 "origin": "3",
 "remoteType": "4",
 "arrayElements": "5",
 "objectValue": "6",
 "properties": "7",
 "functions": "8",
 "serverVersion": "9",
 "messageType": "a",
 "objectName": "b",
 "objectId": "c",
 "functionName": "d",
 "args": "e",
 "objDes": "f",
 "funcDes": "g",
 "arrDes": "h",
 "dateDes": "i",
 "ref": "j",
 "retrieve": "k",
 "invoke": "l",
 "pojo": "m",
 "protocolVersion": "n",
 "messageId": "o",
 "success": "p",
 "error": "q",
 "functionId": "r",
 "buffer": "s",
 "__r_sid": "t",
 "reference": "u",
 "dereference": "v",
 "referenceClient": "w"
}
   */

  keyWordsReverseMap = {};

  for (k in keyWordsMap) {
    v = keyWordsMap[k];
    keyWordsReverseMap[v] = k;
  }


  keywordStrings = {};

  /* 
  Keywords are compressed using keyWordMap,
  we define utility methods in encodeHelper to use normalized key word to
  access compressed key words which are used as property names in remote
  object descriptors.
  */
  encodeHelper = {};

  for (_i = 0, _len = keyWords.length; _i < _len; _i++) {
    var keyWord = keyWords[_i];
    normalized = null;
    // the item is an [name, keyword] array
    if (typeof keyWord !== 'string') {
      normalized = keyWord[0];
      keyWord = keyWord[1];
    }else{
      //normalized name : remove '_' from keyWord
      normalized = keyWord.replace(/_/g, '');  
    }

    // mapping from normalized name to keyword, we use method instead of directly
    // typing keyword so that we get reference error when we made spelling mistakes.
    keywordStrings[normalized] = (function(k){
      return function(){
        return k;
      };
    })(keyWord);
    
    
    // compressed keyword
    keyWordCode = keyWordsMap[keyWord];
    // mapping from normalized name to compressed keyword
    encodeHelper["" + normalized + "Code"] = keyWordCode;
    // upperCase 1st char in normalized name, so we can use it to create
    // helper functions
    normalized = normalized.charAt(0).toUpperCase() + normalized.slice(1);
    // get
    encodeHelper["get" + normalized] = (function(keyWordCode) {
      return function(obj) {
        return obj[keyWordCode];
      };
    })(keyWordCode);
    /* get property in remote object stub or local object,
    property name is not compressed to avoid conflict to user defined
    properties
    */
    encodeHelper["getHidden" + normalized] = (function(keyWord) {
      return function(obj) {
        return obj[keyWord];
      };
    })(keyWord);
    /*
    set property in remote object stub or locl object,
    property name is not compressed to avoid conflict
    */
    encodeHelper["setHidden" + normalized] = (function(keyWord) {
      return function(obj, val) {
        if (val != null) {
          return addHiddenField(obj, keyWord, val);
        }
      };
    })(keyWord);
    // get value that is also part of keywords
    encodeHelper["getFull" + normalized] = (function(keyWordCode) {
      return function(obj) {
        var fullVal, val;
        val = obj[keyWordCode];
        fullVal = val;
        if (val != null) {
          fullVal = keyWordsReverseMap[val];
          if (fullVal == null) {
            throw new Error("cannot find keyWord code " + val + ", return null");
          }
        }
        return fullVal;
      };
    })(keyWordCode);
    // set value, if the third parameter 'valueIsKeyWord' is true, that means
    // the value is also a keyword and it needs to be compressed
    encodeHelper["set" + normalized] = (function(keyWordCode) {
      return function(obj, val, valueIsKeyWord) {
        // the final value
        var cval = val;
        if (valueIsKeyWord && (val != null)) {
          cval = keyWordsMap[val];
          if (cval == null) {
            throw new Error("cannot find keyword " + val);
          }
        }
        if (cval != null) {
          return obj[keyWordCode] = cval;
        }
      };
    })(keyWordCode);
    encodeHelper["set" + normalized + "From"] = (function(keyWordCode) {
      return function(obj, source) {
        if (source[keyWordCode] != null) {
          return obj[keyWordCode] = source[keyWordCode];
        }
      };
    })(keyWordCode);
    encodeHelper["is" + normalized + "Equals"] = (function(keyWordCode) {
      return function(obj, val) {
        if ((val != null) && (obj[keyWordCode] != null)) {
          return val === obj[keyWordCode];
        }
        return (val == null) && (obj[keyWordCode] == null);
      };
    })(keyWordCode);
  }
  // should not mutate the properties of this class
  function ServerIdentifier(host, port){    
    this.host = arguments[0];
    this.port = arguments[1];
  }
  lodash.assign(ServerIdentifier.prototype, {
    equals : function(another){
      if (another==null) {
        return false;
      }
      if (another == this) {
        return true;
      }
      return this.host == another.host && this.port == another.port;
    },
    // we use this as key in lookup maps
    toString : function(){
      if (this.__string == null) {
        this.__string = this.host+":"+this.port;
      }
      return this.__string;
    },
    clone : function(){
      return new ServerIdentifier(this.host, this.port);
    }
  });

  function getHostFromStub(stub){
    var host = encodeHelper.getHiddenRhost(stub);
    var port = encodeHelper.getHiddenRport(stub);
    if (host==null) {
      return null;
    }
    return new ServerIdentifier(host, port);
  }

  exports.encodeHelper = encodeHelper;
  exports.keywordStrings = keywordStrings;

  exports.privatePrefix = '_';


  /*
  __defineGetter__  __defineSetter__   __lookupGetter__  __lookupSetter__  
  constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString        
  toString valueOf toJSON
   */

  exports.excludeMethods = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 
  'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf', 'toJSON'];

  exports.addHiddenField = addHiddenField;
  exports.ServerIdentifier = ServerIdentifier;
  exports.getHostFromStub = getHostFromStub;

}).call(this);
