(function() {
  var EventEmitter = require('events').EventEmitter;

  var weak = require('weak');

  var debug = require('debug');

  var lodash = require('lodash');

  var commonModule = require('./common');
  var stubHelper = commonModule.stubHelper;
  var ServerIdentifier = commonModule.ServerIdentifier;
  

  var logger = debug('nodermi:objRegistry');
  var errorLogger = debug('nodermi:error:objRegistry');


  function RmiReference(val){
    this.val = val;
    this.references = {};
  }

  lodash.assign(RmiReference.prototype, {
    addReference : function(sessionId, client){
      var sessionIds = this.references[client];
      if (sessionIds==null) {
        this.references[client] = [sessionId];
      }else{
        var index = lodash.indexOf(sessionIds, sessionId);
        if (index<0) {
          sessionIds.push(sessionId);  
        }
      }
    },
    // remove a reference to this rmi object,
    // return true if the reference count reaches 0
    removeReference : function(sessionId, client){
      var sessionIds = this.references[client];
      if (sessionIds != null) {
        var index = lodash.indexOf(sessionIds, sessionId);
        if (index<0) {
          errorLogger("cannot find reference for client[" + client + "] for object "
            + stubHelper.getRemoteId(this.val));
          //errorLogger(this.references);
        }else{
          sessionIds.splice(index, 1);
          if (sessionIds.length == 0) {
            delete this.references[client];
            return this.isEmpty();
          }
        }
      }
      return false;
    },
    batchRemove : function(serverList){
      lodash.forEach(serverList, function(server){
        if (this.references[server]) {
          delete this.references[server];
        }
      }, this);
      return this.isEmpty();
    },
    isEmpty : function(){
      var empty = true;
      lodash.forEach(this.references, function(){
        empty = false;
        // end iteration early
        return false;
      });
      return empty;
    },
    getVaule : function(){
      return this.val;
    }
  });

  // if multiple nodermi instances running in the same process, they will assign
  // ids to the same set of objects/functions, use this global idPrefix
  // to guarantee that the ids generated by these instances will never overlap.
  var idPrefix = 0;

  var ObjectRegistry = (function() {
    function ObjectRegistry() {
      //strong reference to hold remote objects that is referenced by clients
      this.objects = {};
      this.idPrefix = idPrefix++;
      this.sequence = 0;
      this.size = 0;
      //weak reference to hold remote stubs
      this.stubs = {};
    }
    // inherit EventEmitter
    ObjectRegistry.prototype = lodash.create(EventEmitter.prototype, {'constructor': ObjectRegistry});
    // register local objects. the caller should make sure obj is not a remote object stub
    ObjectRegistry.prototype.registerObject = function(obj, sessionId, client) {
      var id = stubHelper.getRemoteId(obj);
      // if there is no id assigned, that means it is never registered
      if (id == null) {
        id = this.getSequence();
        stubHelper.setRemoteId(obj, id);
      }
      this._putObject(id, obj, sessionId, client);
      // logger("register " + (typeof obj) + " " + id + "->" + client);
      if (this.sequence % 100 === 0) {
        logger("ObjectRegistry Holds reference to " + this.size + " objects");
      }
      return id;
    };
    // every stub created should be registered exactly once !
    ObjectRegistry.prototype.registerStub = function(stub){
      var host = stubHelper.getHostFromStub(stub);
      var stubObjId = stubHelper.getRemoteId(stub);
      var sessionId = stubHelper.getRemoteSessionId(stub);
      if (sessionId == null) {
        throw new Error("SessionId is mandatory.");
      }
      var stubObjKey = this._getStubKey(host, sessionId, stubObjId);
      if (this.stubs[stubObjKey] == null) {
        this.stubs[stubObjKey] = weak(stub, this._stubCleanupFunc(host, sessionId, stubObjId));
        // logger("register stub " + stubObjKey + " " + (typeof stub));
      }
    };
    // callback for weak to dereference stubs
    ObjectRegistry.prototype._stubCleanupFunc = function(host, sessionId, stubObjId){
      var registry = this;
      return function(){
        logger("cleanup stub " + registry._getStubKey(host, sessionId, stubObjId));
        registry._removeStub(host, sessionId, stubObjId);
      };
    };

    ObjectRegistry.prototype._getStubKey = function(host, sessionId, stubObjId){
      return host + "_" + sessionId + "_" + stubObjId;
    };

    ObjectRegistry.prototype._removeStub = function(host, sessionId, stubObjId){
      var stubKey = this._getStubKey(host, sessionId, stubObjId);
      var stubReference = this.stubs[stubKey];
      if (stubReference != null) {
        delete this.stubs[stubKey];
        this.emit("dereference", host, sessionId, stubObjId);
      };
    };

    ObjectRegistry.prototype.dereference = function(client, sessionId, objId){
      var reference = this.objects[objId];
      if (reference != null) {
        var empty = reference.removeReference(sessionId, client);
        if (empty) {
          logger("Reference to [" + objId + "] cleared, safe to remove from strong map.");
          delete this.objects[objId];
        }
        // logger("after dereference " + objId + " "+ JSON.stringify(reference.references));
      }else{
        errorLogger("Dereference something not exist sessionId[" + sessionId + "], objId ["
          + objId + "]");
      }
    };

    ObjectRegistry.prototype.removeReferenceFrom = function(serverList){
      lodash.forEach(this.objects, function(reference, objId){
        var empty = reference.batchRemove(serverList);
        if (empty) {
          logger("Reference to [" + objId + "] cleared, safe to remove from strong map.");
          delete this.objects[objId];
        }
      }, this);
    };

    ObjectRegistry.prototype._putObject = function(id, obj, sessionId, client) {
      var reference = this.objects[id];
      if (reference == null) {
        reference = new RmiReference(obj);
        this.objects[id] = reference;
        this.size++;
      }
      reference.addReference(sessionId, client);
    };

    ObjectRegistry.prototype.getSequence = function() {
      var id = this.sequence.toString(36);
      if (this.idPrefix > 0) {
        // so instances in the same process will not step on each other
        id = this.idPrefix + '_' + id;
      }
      this.sequence++;
      return id;
    };

    ObjectRegistry.prototype.getObject = function(id) {
      var reference = this.objects[id];
      if (reference == null) {
        return null;
      }
      return reference.getVaule();
    };

    return ObjectRegistry;

  })();

  module.exports = ObjectRegistry;

}).call(this);
