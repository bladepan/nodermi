// Generated by CoffeeScript 1.8.0
(function() {
  var ObjectRegistry, debug, encodeHelper, lodash, logger, weak;

  var EventEmitter = require('events').EventEmitter;

  weak = require('weak');

  debug = require('debug');

  lodash = require('lodash');

  var commonModule = require('./common');
  encodeHelper = commonModule.encodeHelper;
  var ServerIdentifier = commonModule.ServerIdentifier;
  var getHostFromStub = commonModule.getHostFromStub;

  logger = debug('nodermi:objRegistry');
  var errorLogger = debug('nodermi:error:objRegistry');


  function RmiReference (val){
    this.val = val;
    this.references = [];
  }

  lodash.assign(RmiReference.prototype,{
    addReference : function(sessionId, client){
      var key = client + "_" + sessionId;
      var index = lodash.indexOf(this.references, key);
      if (index<0) {
        this.references.push(key);
      }
    },
    // remove a reference to this rmi object,
    // return true if the reference count reaches 0
    removeReference : function(sessionId, client){
      var key = client + "_" + sessionId;
      var index = lodash.indexOf(this.references, key);
      if (index<0) {
        errorLogger("cannot find reference for client[" + client + "] for object "
          + encodeHelper.getHiddenRid(this.val));
        //errorLogger(this.references);
      }else{
        this.references.splice(index, 1);
      }
      if (this.references.length == 0) {
        return true;
      }
      return false;
    },
    getVaule : function(){
      return this.val;
    }
  });


  ObjectRegistry = (function() {
    function ObjectRegistry() {
      //strong reference to hold remote objects that is referenced by clients
      this.objects = {};
      this.sequence = 0;
      this.size = 0;
      //weak reference to hold remote stubs
      this.stubs = {};
    }
    // inherit EventEmitter
    ObjectRegistry.prototype = lodash.create(EventEmitter.prototype, {'constructor': ObjectRegistry});
    // register local objects. the caller should make sure obj is not a remote object stub
    ObjectRegistry.prototype.registerObject = function(obj, sessionId, client) {
      var id = encodeHelper.getHiddenRid(obj);
      // if there is no id assigned, that means it is never registered
      if (id == null) {
        id = this.getSequence();
        encodeHelper.setHiddenRid(obj, id);
      }
      this._putObject(id, obj, sessionId, client);
      if (this.sequence % 100 === 0) {
        logger("ObjectRegistry Holds reference to " + this.size + " objects");
      }
      return id;
    };
    // every stub created should be registered exactly once !
    ObjectRegistry.prototype.registerStub = function(stub){
      var host = getHostFromStub(stub);
      var stubObjId = encodeHelper.getHiddenRid(stub);
      var sessionId = encodeHelper.getHiddenSessionId(stub);
      if (sessionId == null) {
        throw new Error("SessionId is mandatory.");
      }
      var stubObjKey = this._getStubKey(host, sessionId, stubObjId);
      var stubReference = this.stubs[stubObjKey];
      if (stubReference == null) {
        this.stubs[stubObjKey] = weak(stub, this._stubCleanupFunc(host, sessionId, stubObjId));
      }
    };

    ObjectRegistry.prototype._stubCleanupFunc = function(host, sessionId, stubObjId){
      var registry = this;
      return function(){
        logger("cleanup stub " + registry._getStubKey(host, sessionId, stubObjId));
        registry._removeStub(host, sessionId, stubObjId);
      };
    }

    ObjectRegistry.prototype._getStubKey = function(host, sessionId, stubObjId){
      return host+"_"+sessionId+"_"+stubObjId;
    };

    ObjectRegistry.prototype._removeStub = function(host, sessionId, stubObjId){
      var stubKey = this._getStubKey(host, sessionId, stubObjId);
      var stubReference = this.stubs[stubKey];
      if (stubReference != null) {
        delete this.stubs[stubKey];
        this.emit("dereference", host, sessionId, stubObjId);
      };
    };

    ObjectRegistry.prototype.dereference = function(client, sessionId, objId){
      var reference = this.objects[objId];
      if (reference != null) {
        var empty = reference.removeReference(sessionId, client);
        if (empty) {
          logger("Reference to [" + objId + "] cleared, safe to remove from strong map.");
          delete this.objects[objId];
        }
      }else{
        errorLogger("Dereference something not exist sessionId[" + sessionId + "], objId ["
          + objId + "]");
      }
    };

    ObjectRegistry.prototype._putObject = function(id, obj, sessionId, client) {
      var reference = this.objects[id];
      if (reference == null) {
        reference = new RmiReference(obj);
        this.objects[id] = reference;
        this.size++;
      }
      reference.addReference(sessionId, client);
    };

    ObjectRegistry.prototype.getSequence = function() {
      var id = this.sequence.toString(36);
      this.sequence++;
      return id;
    };

    ObjectRegistry.prototype.getObject = function(id) {
      var reference = this.objects[id];
      if (reference == null) {
        return null;
      }
      return reference.getVaule();
    };

    return ObjectRegistry;

  })();

  module.exports = ObjectRegistry;

}).call(this);
